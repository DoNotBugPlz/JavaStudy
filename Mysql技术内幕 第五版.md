# Mysql技术内幕 第五版

### 第四章 视图和存储程序

视图（view）是一种类型的存储对象。视图是一个 **虚拟**表。也就是说，它像是个表，但实际上 **不包含**数据。其实，它是个根据表或其他视图来进行定义的，并且提供了另一种查看表数据的方式。视图提供了一种简单的运行复杂查询的方式，通过这种方式可以简化应用程序的开发。

存储过程（stored program）是另外一种类型的存储对象。它们有很多形式，有些可以按需调用，而其他的则可以在修改表或者达到预定时间时自动执行。

* 存储函数（stored function） 它可以用在表达式里返回某个计算的结果。
* 存储过程（stored procedure） 它不会直接返回结果，但可以用来完成一般的运算，或者生成可以传递回到客户端的结果集。
* 触发器（trigger）它与表关联在一起，当这个表在使用 ***insert，delete，update***语句进行修改时，它会自动运行。
* 事件（event）它会根据计划在预定时刻自动执行。

### 第五章 查询优化

#### 5.1 使用索引

##### 5.1.1 索引的优点

##### 5.1.2 索引的代价

##### 5.1.3 挑选索引

1. **为用于搜索、排序或分组的列创建索引，而对于用作输出显示的列则不用创建索引。**

例如说：

```sql
select 
	col_a     #不是候选列
from
 	tab1 left join tabl2
 	on tabl.col_b = tab2.col_c #候选列
where
	col_d = expr; #候选列
```

*最佳索引的候选列是那些出现在 **where**子句中的列，或者是连接语句中的连接条件的列，或者是ordeby groupby*

2. **认真考虑数据列的基数**

列的基数（**cardingality**）是指它所容纳的所有非重复值的个数。例如：某个列包含值1、3、7、4、7、3那么它的基数为4。相对于表里的行总数越对，基数越大就越好（重复数据越少就越好）。

3. **索引值越短小就越好**
4. **索引字符传值的前缀**

想要对字符串列进行索引，应尽可能的制定前缀长度。例如，你有一个char（200）列，如果大多数值的前10个或20个字符都是唯一的，那么就可以不用为整个列进行索引。而只为前面的10或20个字符进行索引，这样可以节省大量的索引空间，而且还能使查询变的更快。（对短小的值进行索引，可以获得上一条指导中描述过的好处，即减少磁盘I/O操作，加快索引速度。）当然，你可能会想继续沿用某些惯用做法。不过只索引数据列的第一个字符恐怕不行，因为这样做会导致索引无法获得大量的唯一值。

5. **利用最左前缀**

   复合索引中，应该用优先考虑最左侧的索引，例如现在有三列，country/state/city。在索引列里，行的排序为country/state/city，因此行首先会自动按country/state顺序排序，然互再按country进行排序，这意味着，即使在查询里只指定了country值，或者只指定了country值和state值，Mysql也可以充分利用索引。因此，索引可用于搜索下列组合：

   Country，State，City

   Country，State

   Country

   #### 5.2 查询优化原理

   ##### 5.2.1查询优化程序的工作原理

   1. 使用explain优化程序的操作

   使用explain语句可以了解到各个索引是否会被用到。当你尝试使用各种不同的办法来编写某一条语句时，或者很想知道增加索引对于命中的执行系哦啊率是否会有改善时，这类信息可以派上用场。

   2. 在必要时给予优化程序提示或改写它

   例如可以在表名的后面加上force index，use index 或 ignore index。

   例如可以使用Straight join来进行指定连接表的顺序，通常意义上。先指定行数结果集少的表更容易找到目标。

   ---

   

   ***①这里给给出的对这句话的理解。一个列可以有多个索引例如hash索引和Btree索引，hash索引在精确匹配的时候非常的快，但对于比较大小或者模糊匹配比较慢。但Btree善于做这方面的匹配，例如指定使用hash索引对于一个精确查询非常有效。***

   ***②建立索引对于insert语句和delete语句很不友好，ignore index可以忽略索引***

   ---

   3. 比较拥有相同数据类型的列

   这个很好理解，需要知道的是char(10)和char(12)数据库会认为是不同的数据类型。

   4. 让索引在表达式中单独出现

   给个栗子：

   ```sql
   where col_b *2 <4 # 例如说col_b是建立好的索引列，那么这条语句是不会走索引的，因为这条语句是先把所有的col_b都进行一次计算，再和4比
   ```

   可以写成这样

   ```sql
   where col_b < 4/2 这样就是先计算出一个衡量，然后再和col_b走索引进行比较。
   ```

   5. 不要将通配符放在like模式的前面

   例如，不要这么写:

   ```sql
   where col_b like "%dn%"
   ```

   除非你想查出只包含dn的字符，那么查询结果势必将很长。

   6. 测试查询的各种结果，并多次运行他们

   这个很简单，因为第一次查询的结果，会放在磁盘的高速缓存里，这样第二次查询总是会被第一次快一些，尽量在负载较低的情况下。

   7. 避免过多使用自动类型转换

   例如，num_col是一个整型列，下面两个查询都可以返回相同的结果:

   ```sql
   select * from mytbl where num_col =4;
   select * from mytbl where num_col= '4';
   ```

   但是第二个查询牵扯到类型转换。这个类型转换自身又涉及一个很小的性能损失的问题，因为它需要将整数和字符串转换成双精度数，以完成比较操作。更为严重的问题是，如果num_col列带有索引，那么涉及类型转的比较可能阻止使用索引。

   ##### 5.2.2 使用explain检查优化过程

   